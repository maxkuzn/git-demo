# Git cheatsheet

## Список команд

### База

#### `git clone <repo_address>`  

Клонирует репозиторий локально.

---

#### `git push`  

Добавляет локальные изменения (коммиты) на сервер. 

---

#### `git fetch`

Получает информацию об изменениях на сервере во всех ветках, но при этом не меняет ветки локально.

После этой команды `git status` будет писать, что ветка на сервере опережает локальную на N коммитов.

---

#### `git pull`

Получает информацию об изменениях на сервере, и обновляет текущую ветку, чтобы она была, как на сервере.

---

#### `git status`

Показывает текущий статус - текущая ветка, измененные файлы, насколько ветка опережает/отстает от ветки на сервере.

---

### Взаимодействие с файлами (для коммита)

#### `git add <filename>`

Добавляет файл `<filename>` в будущий коммит.

---

#### `git rm <filename>`

Удаляет файл `<filename>` и добавляет это в коммит.

---

#### `git mv <old_filename> <new_filename>`

Переименовывает файл из `<old_filename>` в `<new_filename>` и добавляет это в коммит.

---

#### `git mv <old/path/to/filename> <new/path/to/filename>`

Более общий способ использования команды - перемещает файл из одного места в другое - имя файла можно менять, а можно оставить.

---


#### `git restore --staged <filename>`

Отменяет добавление в коммит файла `<filename>` после, например, `git add`. Сам файл при этом не возвращается к предыдущей версии, а остается измененным. 

---

#### `git restore <filename>`

Возвращает предыдущую версию файла `<filename>` до изменений. Работает только для файлов, которые еще не добавили в коммит.  
Если же файл уже добавлен в коммит, то его можно убрать оттуда предыдущей командой.

---


#### `git commit -m "<message>"`

Делает коммит всех добавленных изменений.  
При этом коммит остается только в локальной версии - для загрузки его на сервер нужно выполнить `git push`.

---

#### `git commit --amend`

Обновляет предыдущий коммит - полезно в случаях, когда хочется поменять `<message>` или забыли добавить какие-то файлы.  
Не стоит делать после выполненного `git push`.

Есть два варианта:
1. Меняем `<message>` - `git commit --amend -m "<new_message>"`
2. Оставляем `<message>` - `git commit --amend --no-edit`

*Пример использования:*
```
# Делаем изменения
...

# Создаем коммит
git commit -m "some commit"

# Добавляем файл, который хотим добавить в предыдущий коммит
git add main.py 

# Обновляем предыдущий коммит, добавив туда файл и изменив message
git commit --amend -m "the same commit"  
```

---

### Взаимодействие с ветками

#### `git branch`

Выводит список веток, которые на данный момент находятся **локально**.  

___

#### `git checkout -b <branch_name>`

Создает новую ветку с названием `<branch_name>` **локально** и переключается на него.  
При этом эта ветка не создается на сервере - для этого нужно сделать `git push --set-upstream` (см. ниже).

---

#### `git checkout <branch_name>`

Переключает на ветку `<branch_name>`.

---

#### `git push --set-upstream <remote_name> <branch_name>`

Создает ветку `<branch_name>` **на сервере** `<remote_name>`:

- `<remote_name>` почти всегда равен `origin`
- Ветка `<branch_name>` должна существовать локально
- На самом деле, эту команду не нужно запоминать (см. пример ниже с созданием ветки).

---


#### `git branch -d <branch_name>`

Удаляет ветку `<branch_name>` **локально**.  
Данная команда не позволит удалить ветку, если в ней есть коммиты, которых нет на сервере. То есть:

- Выполнили `git commit`
- Не выполнили `git push`

---

#### `git branch -D <branch_name>`

То же самое, что и предыдущее, но позволяет удалить ветку даже с коммитами, которых нет на сервере - эту команду обычно не нужно использовать.

---

#### `git push -d <remote_name> <branch_name>`

Удаляет ветку `<branch_name>` **на сервере** `<remote_name>`.  
Опять же, обычно `<remote_name>` = `origin`.

---

### Еще полезные штуки

#### `git diff`

Показывает, какие файлы и как изменились (построчно).  
Не показывает файлы, которые были добавлены в коммит.

---

#### `git diff --cached`

Показывает, какие файлы и как изменились (построчно).  
Показывает только файлы, которые были добавлены в коммит.

---

#### `git log`

Показывает список коммитов.  

---

#### `git stash`

Запоминает **все** изменения (и просто измененные файлы, и добавленные в коммит) и скрывает их.

---

#### `git stash pop`

Восстанавливает изменения, скрытые командой `git stash`.

Предыдущие две команды полезны, когда по ошибке сейчас `git` находится в одной ветке, а закомитить изменения нужно в другую.  
Например, комитить нужно в `my_branch`, а на данный момент мы находимся в `main`.  
В таком случае простой `git checkout my_branch` не сработает, потому что нельзя менять ветку, если есть какие-то изменения файлов. Но можно их скрыть!
```
# Скрываем все изменения
$ git stash

# Меняем на нужную ветку
$ git checkout my_branch

# Восстанавливает изменения уже в нужной ветке
$ git stash pop
```

---

## Сценарии

### Создание коммита

```
# Добавляем изменения
$ git add <files>

# Делаем коммит
$ git commit -m "commit message"

# Заливаем на сервер
$ git push
```

`git push` не обязательно делать после каждого коммита - его достаточно сделать один раз в *условном конце работы*.
```
$ git add file_one
$ git commit -m "commit one"
$ git add file_two
$ git commit -m "commit two"
$ git add file_one file_two
$ git commit -m "commit three"

$ git push
```

---

### Создание ветки с изменениями

```
# Создаем новую ветку
$ git checkout -b my_branch

# Делаем разные коммиты
$ git add files && git commit -m "commit message" && ...

# Заливаем на сервер
$ git push
# Но первый раз так нельзя, потому что ветки нет на сервере
# Ее нужно создать, но git push в сообщении ошибки подскажет,
# какой командой нужно создать ветку на сервере

# Заливаем на сервер, создавая при этом ветку
$ git push --set-upstream origin my_branch 
# После этого, если нужно будет что-то еще добавить, то уже
# будет работать git push
```

После этого, скорее всего, нужно будет сделать Pull request (PR) на сайте. Github сам предложит это сделать.

---

### Обновление PR'а

После создания PR'а могут попросить что-то поменять.

```
# Проверяем текущую ветку
$ git status

# Переключаемся на нужную ветку (если находимся в другой)
$ git checkout my_branch

# Делаем разные коммиты
$ git add files && git commit -m "commit message" && ...

# Заливаем на сервер
$ git push
```

---

### PR Merge

После апрува в PR'е делаем merge. Но у нас остается ветка, которая больше не нужна.   
По-хорошему, стоит ее удалить, чтобы она ничего не засоряла.

```
# Переключаемся на любую другую ветку (иначе не даст удалить)
$ git checkout main

# Даем git'у понять, что ветка была влита в другую ветку
$ git fetch

# Удаляем ветку на сервере
$ git push -d origin my_branch

# Удаляем ветку локально
$ git branch -d my_branch
```

При этом, GitHub может сам предложить удалить ветку на сервере (где-то рядом с кнопкой Merge).  
В таком случае третий шаг можно пропустить.  

Стоит еще отметить, что после merge на сервере обновилась ветка, куда мы делали merge (скорее всего, ветка `main` или `master`).  
Нам нужно скачать новую версию ветки локально.

```
# Переключаемся на ветку main
$ git checkout main

# Обновляем ветку
$ git pull
```